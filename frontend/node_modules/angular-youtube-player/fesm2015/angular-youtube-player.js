import { Injectable, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Component, Input, Output, NgModule } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class YTPlayerConfig {
    /**
     * @param {?=} shouldLoadAPI
     * @param {?=} multiplePlaying
     */
    constructor(shouldLoadAPI = YTPlayerConfig.defaultConfig.shouldLoadAPI, multiplePlaying = YTPlayerConfig.defaultConfig.multiplePlaying) {
        this.shouldLoadAPI = shouldLoadAPI;
        this.multiplePlaying = multiplePlaying;
    }
}
YTPlayerConfig.defaultConfig = { shouldLoadAPI: true, multiplePlaying: false };
if (false) {
    /** @type {?} */
    YTPlayerConfig.defaultConfig;
    /** @type {?} */
    YTPlayerConfig.prototype.shouldLoadAPI;
    /** @type {?} */
    YTPlayerConfig.prototype.multiplePlaying;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} string
 * @return {?}
 */
function parseQueryString(string) {
    if (/(?:[\w_]+=(?:[\w\d]+|\d)&?)+/.test(string)) {
        /** @type {?} */
        const parsed = {};
        string.split('&').forEach((/**
         * @param {?} query
         * @return {?}
         */
        query => {
            /** @type {?} */
            const pair = query.split('=');
            parsed[pair[0]] = pair[1];
        }));
        return parsed;
    }
    else {
        throw new Error('Bad string format, please refer to https://developers.google.com/youtube/player_parameters');
    }
}
/**
 * @return {?}
 */
function loadAPI() {
    return new Promise((/**
     * @param {?} resolve
     * @return {?}
     */
    resolve => {
        window['onYouTubeIframeAPIReady'] = resolve;
        /** @type {?} */
        const tag = window.document.createElement('script');
        tag.src = 'https://www.youtube.com/iframe_api';
        /** @type {?} */
        const firstScriptTag = window.document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class YTPlayerService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.apiReady = new BehaviorSubject(window['YT'] !== undefined);
        this.players = new Array();
        this.multiplePlaying = config.multiplePlaying;
        if (config.shouldLoadAPI !== false) {
            loadAPI().then((/**
             * @return {?}
             */
            () => this.apiReady.next(true)));
        }
        else if (this.apiReady.value === false) {
            console.warn('YT API not loaded');
        }
    }
    /**
     * @return {?}
     */
    get playersCount() {
        return this.players.length;
    }
    /**
     * @param {?} player
     * @return {?}
     */
    addPlayer(player) {
        this.players.push(player);
    }
    /**
     * @param {?} player
     * @return {?}
     */
    removePlayer(player) {
        /** @type {?} */
        const index = this.players.indexOf(player);
        this.players.splice(index, 1);
    }
    /**
     * @param {?} playerComponent
     * @return {?}
     */
    pauseAllExcept(playerComponent) {
        if (this.multiplePlaying) {
            return;
        }
        /** @type {?} */
        const exception = this.players.indexOf(playerComponent);
        if (exception > -1) {
            this.players.forEach((/**
             * @param {?} player
             * @param {?} index
             * @return {?}
             */
            (player, index) => {
                if (exception !== index) {
                    player.pause();
                }
            }));
        }
    }
}
YTPlayerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
YTPlayerService.ctorParameters = () => [
    { type: YTPlayerConfig }
];
/** @nocollapse */ YTPlayerService.ngInjectableDef = ɵɵdefineInjectable({ factory: function YTPlayerService_Factory() { return new YTPlayerService(ɵɵinject(YTPlayerConfig)); }, token: YTPlayerService, providedIn: "root" });
if (false) {
    /** @type {?} */
    YTPlayerService.prototype.apiReady;
    /**
     * @type {?}
     * @private
     */
    YTPlayerService.prototype.players;
    /**
     * @type {?}
     * @private
     */
    YTPlayerService.prototype.multiplePlaying;
    /**
     * @type {?}
     * @private
     */
    YTPlayerService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class YTPlayerComponent {
    /**
     * @param {?} ytPlayerService
     */
    constructor(ytPlayerService) {
        this.ytPlayerService = ytPlayerService;
        this.ready = new EventEmitter();
        this.unstarted = new EventEmitter();
        this.ended = new EventEmitter();
        this.playing = new EventEmitter();
        this.paused = new EventEmitter();
        this.buffering = new EventEmitter();
        this.cued = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get currentTime() {
        return this.player.getCurrentTime();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ytPlayerService.addPlayer(this);
        this.domId = this.domId || this.videoId || 'ng-yt-player-' + this.ytPlayerService.playersCount;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.ytPlayerService.apiReady.subscribe((/**
         * @param {?} ready
         * @return {?}
         */
        ready => {
            if (ready && !this.player) {
                /** @type {?} */
                const parameters = typeof this.parameters === 'string' ? parseQueryString(this.parameters) : this.parameters;
                this.player = this.initPlayer(this.videoId, parameters, this.domId);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.ytPlayerService.removePlayer(this);
    }
    /**
     * @return {?}
     */
    play() {
        if (this.isReady) {
            this.player.playVideo();
        }
        else {
            console.warn('The player was not ready when tried to play.');
        }
    }
    /**
     * @return {?}
     */
    pause() {
        if (this.isReady) {
            this.player.pauseVideo();
        }
        else {
            console.warn('The player was not ready when tried to pause.');
        }
    }
    /**
     * @param {?} videoId
     * @param {?=} startSeconds
     * @return {?}
     */
    cueVideoById(videoId, startSeconds) {
        if (this.isReady) {
            this.player.cueVideoById(videoId, startSeconds);
        }
        else {
            console.warn('The player was not ready when tried to cueVideoById.');
        }
    }
    /**
     * @param {?} videoId
     * @param {?=} startSeconds
     * @return {?}
     */
    loadVideoById(videoId, startSeconds) {
        if (this.isReady) {
            this.player.loadVideoById(videoId, startSeconds);
        }
        else {
            console.warn('The player was not ready when tried to loadVideoById.');
        }
    }
    /**
     * @private
     * @return {?}
     */
    onplay() {
        this.playing.emit();
        this.ytPlayerService.pauseAllExcept(this);
    }
    /**
     * @private
     * @param {?} videoId
     * @param {?} playerVars
     * @param {?} domId
     * @return {?}
     */
    initPlayer(videoId, playerVars, domId) {
        /** @type {?} */
        const onReady = (/**
         * @return {?}
         */
        () => {
            if (!this.isReady) {
                this.ready.emit();
                this.isReady = true;
            }
        });
        /** @type {?} */
        const onStateChange = (/**
         * @param {?} __0
         * @return {?}
         */
        ({ data }) => {
            switch (data) {
                case -1 /* UNSTARTED */:
                    this.unstarted.emit();
                    break;
                case 0 /* ENDED */:
                    this.ended.emit();
                    break;
                case 1 /* PLAYING */:
                    this.onplay();
                    break;
                case 2 /* PAUSED */:
                    this.paused.emit();
                    break;
                case 3 /* BUFFERING */:
                    this.buffering.emit();
                    break;
                case 5 /* CUED */:
                    this.cued.emit();
                    break;
            }
        });
        return new YT.Player(domId, {
            videoId,
            playerVars,
            events: { onReady, onStateChange }
        });
    }
}
YTPlayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-ytplayer',
                template: '<div [id]="domId"></div>',
                styles: [':host, :host ::ng-deep iframe { display: block; width: 100%; height: 100%; }']
            }] }
];
/** @nocollapse */
YTPlayerComponent.ctorParameters = () => [
    { type: YTPlayerService }
];
YTPlayerComponent.propDecorators = {
    videoId: [{ type: Input }],
    domId: [{ type: Input }],
    parameters: [{ type: Input }],
    ready: [{ type: Output }],
    unstarted: [{ type: Output }],
    ended: [{ type: Output }],
    playing: [{ type: Output }],
    paused: [{ type: Output }],
    buffering: [{ type: Output }],
    cued: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    YTPlayerComponent.prototype.videoId;
    /** @type {?} */
    YTPlayerComponent.prototype.domId;
    /** @type {?} */
    YTPlayerComponent.prototype.parameters;
    /** @type {?} */
    YTPlayerComponent.prototype.ready;
    /** @type {?} */
    YTPlayerComponent.prototype.unstarted;
    /** @type {?} */
    YTPlayerComponent.prototype.ended;
    /** @type {?} */
    YTPlayerComponent.prototype.playing;
    /** @type {?} */
    YTPlayerComponent.prototype.paused;
    /** @type {?} */
    YTPlayerComponent.prototype.buffering;
    /** @type {?} */
    YTPlayerComponent.prototype.cued;
    /**
     * @type {?}
     * @private
     */
    YTPlayerComponent.prototype.player;
    /**
     * @type {?}
     * @private
     */
    YTPlayerComponent.prototype.isReady;
    /**
     * @type {?}
     * @private
     */
    YTPlayerComponent.prototype.ytPlayerService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = YTPlayerConfig.defaultConfig;
class YTPlayerModule {
}
YTPlayerModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [YTPlayerComponent],
                providers: [{ provide: YTPlayerConfig, useValue: ɵ0 }],
                exports: [YTPlayerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { YTPlayerComponent, YTPlayerConfig, YTPlayerModule, YTPlayerService, loadAPI };
//# sourceMappingURL=angular-youtube-player.js.map
